<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <title>2D Jewelry AR ‚Äì Earrings + Necklace</title>

    <!-- MediaPipe FaceMesh -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js"></script>
    <!-- MediaPipe Hands -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>

    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet">
    <style>
        * {
            box-sizing: border-box;
        }

        body {
            margin: 0;
            padding: 0;
            font-family: 'Inter', sans-serif;
            background: #000;
            overflow: hidden;
            height: 100vh;
            width: 100vw;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        /* Full Screen Video - Using 'cover' to maintain aspect ratio and prevent distortion */
        video {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scaleX(-1);
            width: 100%;
            height: 100%;
            object-fit: cover;
            z-index: 1;
        }

        /* AR Overlay Elements */
        .jewel {
            position: absolute;
            pointer-events: none;
            z-index: 10;
            transform-origin: 50% 0%;
            /* Aligned with logic update */
            display: none;
        }

        /* Controls Container */
        .controls {
            position: absolute;
            top: 16px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 20;
            width: 90%;
            max-width: 520px;
            background: rgba(255, 255, 255, 0.15);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 18px;
            padding: 14px;
            display: none;
            flex-direction: column;
            gap: 12px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            transition: opacity 0.3s ease, transform 0.2s ease;
        }

        .controls.hidden {
            display: none !important;
        }

        .control-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 10px;
            width: 100%;
        }

        /* Settings toggle button */
        #settingsToggle {
            position: absolute;
            top: 12px;
            right: 12px;
            z-index: 25;
            border: none;
            background: rgba(255, 255, 255, 0.9);
            color: #000;
            font-weight: 600;
            font-size: 14px;
            padding: 10px 16px;
            border-radius: 12px;
            cursor: pointer;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.25);
        }

        #settingsToggle:active {
            transform: scale(0.97);
        }

        .controls .close-btn {
            align-self: flex-end;
            border: none;
            background: rgba(255, 255, 255, 0.15);
            color: #fff;
            font-weight: 600;
            font-size: 14px;
            padding: 6px 10px;
            border-radius: 8px;
            cursor: pointer;
        }

        /* Buttons */
        button {
            border: none;
            background: rgba(255, 255, 255, 0.9);
            color: #000;
            font-weight: 600;
            font-size: 14px;
            padding: 12px 20px;
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.2s;
            flex: 1;
            white-space: nowrap;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        }

        button:active {
            transform: scale(0.96);
            background: #fff;
        }

        button#start {
            background: linear-gradient(135deg, #6C63FF, #4A40E5);
            color: white;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            padding: 16px 32px;
            font-size: 18px;
            border-radius: 50px;
            z-index: 30;
            box-shadow: 0 4px 15px rgba(108, 99, 255, 0.4);
            flex: none;
            width: auto;
        }

        button#start.active {
            display: none;
        }

        button#uploadNecklaceBtn {
            background: rgba(255, 255, 255, 0.2);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.3);
        }

        /* Slider */
        label {
            color: white;
            font-size: 13px;
            display: flex;
            flex-direction: column;
            gap: 5px;
            width: 100%;
        }

        input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            width: 100%;
            height: 6px;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 5px;
            outline: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #fff;
            cursor: pointer;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.2);
        }

        /* Responsive Styles */
        @media (max-width: 768px) {
            .controls {
                top: 12px;
                padding: 12px;
                gap: 10px;
                border-radius: 16px;
            }

            button {
                font-size: 13px;
                padding: 10px 16px;
            }

            button#start {
                font-size: 16px;
                padding: 14px 28px;
            }

            label {
                font-size: 12px;
            }

            input[type="range"] {
                height: 5px;
            }

            input[type="range"]::-webkit-slider-thumb {
                width: 18px;
                height: 18px;
            }
        }

        @media (max-width: 480px) {
            .controls {
                top: 8px;
                padding: 10px;
                gap: 8px;
                width: 94%;
            }

            button {
                font-size: 12px;
                padding: 9px 14px;
            }

            button#start {
                font-size: 15px;
                padding: 12px 24px;
            }

            .control-row {
                flex-direction: column;
                gap: 8px;
            }

            .control-row:first-child {
                flex-direction: row;
            }
        }

        /* Handle landscape orientation on mobile */
        @media (max-height: 500px) and (orientation: landscape) {
            .controls {
                top: 6px;
                padding: 8px;
                gap: 6px;
            }

            button {
                font-size: 11px;
                padding: 8px 12px;
            }
        }
    </style>
</head>

<body>

    <button id="start">üì∏ Enable Camera</button>
    <button id="settingsToggle" style="display:none;">‚öôÔ∏è Show Options</button>

    <div class="controls" id="ui-controls" style="display:none;">
        <button class="close-btn" id="controlsClose">‚úï Close</button>
        <div class="control-row">
            <button id="toggleNecklace">üëÅÔ∏è Show/Hide</button>
            <button id="uploadNecklaceBtn">üì§ Upload Photo</button>
        </div>
        <div class="control-row">
            <label>
                Necklace Height Adjustment
                <input type="range" id="neckHeight" min="-100" max="100" value="100">
            </label>
        </div>
        <div class="control-row">
            <label style="flex:1; color:white; display:flex; align-items:center; gap:8px;">
                <input type="checkbox" id="removeBgToggle" >
                Remove background on upload (downloads result)
            </label>
        </div>
        <div class="control-row">
            <label style="flex:1; color:white; display:flex; align-items:center; gap:8px;">
                <input type="radio" name="jewelryType" id="jewelryTypeHand" value="hand" checked>
                Hand Bracelet
            </label>
            <label style="flex:1; color:white; display:flex; align-items:center; gap:8px;">
                <input type="radio" name="jewelryType" id="jewelryTypeNeck" value="neck">
                Necklace
            </label>
            <label style="flex:1; color:white; display:flex; align-items:center; gap:8px;">
                <input type="radio" name="jewelryType" id="jewelryTypeFinger" value="finger">
                Finger Ring
            </label>
        </div>
    </div>

    <!-- Hidden native inputs -->
    <input type="file" id="uploadNecklaceInput" accept="image/*" style="display: none;">

    <video id="video" autoplay muted playsinline></video>

    <!-- Earrings -->
    <img id="earLeft" class="jewel" src="assets/ear-ring-2.png">
    <img id="earRight" class="jewel" src="assets/ear-ring-2.png">

    <!-- Necklace -->
    <img id="necklace" class="jewel" src="assets/rm.png">

    <!-- Hand Bracelet -->
    <img id="bracelet" class="jewel" src="assets/bracelight.png">

    <!-- Finger Ring -->
    <img id="fingerRing" class="jewel" src="assets/bracelight.png">

    <script>
        /* =====================================================
           BASIC SETUP
        ===================================================== */

        const video = document.getElementById("video");
        const btnStart = document.getElementById("start");
        const btnNecklace = document.getElementById("toggleNecklace");
        const btnUpload = document.getElementById("uploadNecklaceBtn");
        const inputUpload = document.getElementById("uploadNecklaceInput");
        const sliderHeight = document.getElementById("neckHeight");
        const settingsToggle = document.getElementById("settingsToggle");
        const controlsClose = document.getElementById("controlsClose");
        const removeBgToggle = document.getElementById("removeBgToggle");

        const earL = document.getElementById("earLeft");
        const earR = document.getElementById("earRight");
        const necklaceEl = document.getElementById("necklace");
        const braceletEl = document.getElementById("bracelet");
        const fingerRingEl = document.getElementById("fingerRing");

        let showNecklace = false;
        let showBracelet = false;
        let showFingerRing = false;

        let faceMesh, hands, videoRect;
        let videoDisplayInfo = { width: 0, height: 0, offsetX: 0, offsetY: 0 };
        const FACE_ML_INTERVAL = 200;  // Process face every 200ms
        const HAND_ML_INTERVAL = 200;  // Process hands every 200ms
        let lastFaceML = 0;
        let lastHandML = 0;
        let frameCounter = 0;  // For alternating processing

        const SMOOTH = 0.25;

        const smooth = {
            earL: { x: 0, y: 0 },
            earR: { x: 0, y: 0 },
            neck: { x: 0, y: 0 },
            bracelet: { x: 0, y: 0, angle: 0 },
            fingerRing: { x: 0, y: 0, angle: 0 }
        };

        // Jewelry type selection
        const jewelryTypeHand = document.getElementById("jewelryTypeHand");
        const jewelryTypeNeck = document.getElementById("jewelryTypeNeck");
        const jewelryTypeFinger = document.getElementById("jewelryTypeFinger");

        /* =====================================================
           CAMERA
        ===================================================== */

        // Function to update videoRect and calculate actual displayed video area
        function updateVideoRect() {
            videoRect = video.getBoundingClientRect();
            
            // Calculate actual displayed video dimensions with object-fit: cover
            if (video.videoWidth && video.videoHeight) {
                const containerAspect = videoRect.width / videoRect.height;
                const videoAspect = video.videoWidth / video.videoHeight;
                
                if (videoAspect > containerAspect) {
                    // Video is wider - height is the limiting factor
                    videoDisplayInfo.height = videoRect.height;
                    videoDisplayInfo.width = videoRect.height * videoAspect;
                    videoDisplayInfo.offsetX = (videoRect.width - videoDisplayInfo.width) / 2;
                    videoDisplayInfo.offsetY = 0;
                } else {
                    // Video is taller - width is the limiting factor
                    videoDisplayInfo.width = videoRect.width;
                    videoDisplayInfo.height = videoRect.width / videoAspect;
                    videoDisplayInfo.offsetX = 0;
                    videoDisplayInfo.offsetY = (videoRect.height - videoDisplayInfo.height) / 2;
                }
            } else {
                // Fallback if video dimensions not available yet
                videoDisplayInfo.width = videoRect.width;
                videoDisplayInfo.height = videoRect.height;
                videoDisplayInfo.offsetX = 0;
                videoDisplayInfo.offsetY = 0;
            }
        }

        // Handle window resize and orientation change
        let resizeTimeout;
        function handleResize() {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(() => {
                if (video.videoWidth && video.videoHeight) {
                    updateVideoRect();
                }
            }, 100);
        }
        
        window.addEventListener('resize', handleResize);
        window.addEventListener('orientationchange', () => {
            setTimeout(handleResize, 200); // Delay for orientation change to complete
        });

        function showControls() {
            document.getElementById('ui-controls').style.display = 'flex';
            settingsToggle.textContent = '‚úï Hide Options';
        }

        function hideControls() {
            document.getElementById('ui-controls').style.display = 'none';
            settingsToggle.textContent = '‚öôÔ∏è Show Options';
        }

        settingsToggle.onclick = () => {
            const isVisible = document.getElementById('ui-controls').style.display === 'flex';
            if (isVisible) hideControls(); else showControls();
        };

        controlsClose.onclick = () => hideControls();

        btnStart.onclick = async () => {
            btnStart.disabled = true;
            btnStart.classList.add('active'); // Hide start button
            settingsToggle.style.display = 'block';

            // Request camera with ideal constraints for better aspect ratio handling
            const constraints = {
                video: {
                    width: { ideal: 1280 },
                    height: { ideal: 720 },
                    facingMode: 'user'
                }
            };

            video.srcObject = await navigator.mediaDevices.getUserMedia(constraints);
            video.onloadedmetadata = () => {
                // Video dimensions are now available
                updateVideoRect();
            };
            video.onloadeddata = () => {
                video.play();
                updateVideoRect(); // Ensure it's updated after play
                initFaceMesh();
                initHands();
                requestAnimationFrame(loop);
            };
        };

        /* =====================================================
           TOGGLE NECKLACE
        ===================================================== */

        btnNecklace.onclick = () => {
            showNecklace = !showNecklace;
            necklaceEl.style.display = showNecklace ? "block" : "none";
        };

        /* =====================================================
           UPLOAD NECKLACE
        ===================================================== */

        // Helper function to set necklace image and show it
        function setNecklaceImage(imageUrl) {
            necklaceEl.src = imageUrl;
            if (!showNecklace) {
                showNecklace = true;
                necklaceEl.style.display = "block";
            }
        }

        // Helper function to set bracelet image and show it
        function setBraceletImage(imageUrl) {
            braceletEl.src = imageUrl;
            if (!showBracelet) {
                showBracelet = true;
                braceletEl.style.display = "block";
                braceletEl.style.transform = "rotate(90deg)";
            }
        }

        // Helper function to set finger ring image and show it
        function setFingerRingImage(imageUrl) {
            fingerRingEl.src = imageUrl;
            if (!showFingerRing) {
                showFingerRing = true;
                fingerRingEl.style.display = "block";
            }
        }

        // Helper function to download image
        function downloadImage(blob, filename = 'necklace-no-bg.png') {
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        btnUpload.onclick = () => {
            inputUpload.click();
        };

        inputUpload.onchange = async (e) => {
            const file = e.target.files[0];
            if (!file) return;

            // Get selected jewelry type
            let selectedType = 'hand';
            if (jewelryTypeHand.checked) selectedType = 'hand';
            else if (jewelryTypeNeck.checked) selectedType = 'neck';
            else if (jewelryTypeFinger.checked) selectedType = 'finger';

            // Handle finger type
            if (selectedType === 'finger') {
                // Finger ring will be handled below in the upload logic
            }

            const apiKey = '9fbSbQuJMi9a4GyPkvpXsdQK'; // API Key from removed-bg implementation

            // If remove-bg toggle is OFF, just use the uploaded image directly
            if (!removeBgToggle.checked) {
                const reader = new FileReader();
                reader.onload = (evt) => {
                    if (selectedType === 'neck') {
                        setNecklaceImage(evt.target.result);
                    } else if (selectedType === 'hand') {
                        setBraceletImage(evt.target.result);
                    } else if (selectedType === 'finger') {
                        setFingerRingImage(evt.target.result);
                    }
                };
                reader.readAsDataURL(file);
                return;
            }

            const formData = new FormData();
            formData.append('image_file', file);
            formData.append('size', 'auto');

            try {
                const response = await fetch('https://api.remove.bg/v1.0/removebg', {
                    method: 'POST',
                    headers: { 'X-Api-Key': apiKey },
                    body: formData
                });

                if (!response.ok) throw new Error('Failed to remove background');

                const blob = await response.blob();
                const url = URL.createObjectURL(blob);

                // Set the removed-bg image based on selected type
                if (selectedType === 'neck') {
                    setNecklaceImage(url);
                    downloadImage(blob, `necklace-no-bg-${Date.now()}.png`);
                } else if (selectedType === 'hand') {
                    setBraceletImage(url);
                    downloadImage(blob, `bracelet-no-bg-${Date.now()}.png`);
                } else if (selectedType === 'finger') {
                    setFingerRingImage(url);
                    downloadImage(blob, `finger-ring-no-bg-${Date.now()}.png`);
                }

            } catch (error) {
                console.error('Background removal failed:', error);
                // Fallback: If API fails, directly use the uploaded image
                const reader = new FileReader();
                reader.onload = (evt) => {
                    if (selectedType === 'neck') {
                        setNecklaceImage(evt.target.result);
                    } else if (selectedType === 'hand') {
                        setBraceletImage(evt.target.result);
                    } else if (selectedType === 'finger') {
                        setFingerRingImage(evt.target.result);
                    }
                };
                reader.readAsDataURL(file);
            }
        };

        /* =====================================================
           MEDIAPIPE
        ===================================================== */

        function initFaceMesh() {
            faceMesh = new FaceMesh({
                locateFile: f => `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${f}`
            });

            faceMesh.setOptions({
                maxNumFaces: 1,
                refineLandmarks: false,  // Disabled for better performance (reduces CPU usage)
                minDetectionConfidence: 0.5,
                minTrackingConfidence: 0.5
            });

            faceMesh.onResults(onFace);
        }

        function initHands() {
            hands = new Hands({
                locateFile: f => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}`
            });

            hands.setOptions({
                maxNumHands: 1,  // Reduced from 2 to 1 for better performance
                modelComplexity: 0,  // Reduced from 1 to 0 (lightest model) for better performance
                minDetectionConfidence: 0.5,
                minTrackingConfidence: 0.5
            });

            hands.onResults(onHands);
        }

        async function loop(ts) {
            // Only process face detection if earrings or necklace are visible
            const needsFaceDetection = true; // Always needed for earrings
            
            // Only process hands if bracelet or finger ring are visible
            const needsHandDetection = showBracelet || showFingerRing;
            
            // Process face detection with separate interval
            if (needsFaceDetection && ts - lastFaceML > FACE_ML_INTERVAL) {
                lastFaceML = ts;
                await faceMesh.send({ image: video });
            }
            
            // Process hand detection with separate interval (only if needed)
            if (needsHandDetection && ts - lastHandML > HAND_ML_INTERVAL) {
                lastHandML = ts;
                await hands.send({ image: video });
            } else if (!needsHandDetection) {
                // Hide hand-related elements when not needed
                braceletEl.style.display = "none";
                fingerRingEl.style.display = "none";
            }
            
            requestAnimationFrame(loop);
        }

        /* =====================================================
           UTILS
        ===================================================== */

        const lerp = (a, b, t) => a + (b - a) * t;
        const clamp = (v, min, max) => Math.max(min, Math.min(max, v));

        function toScreen(p) {
            // Map MediaPipe normalized coordinates (0-1) to actual displayed video area
            // Account for object-fit: cover and any cropping
            const x = (1 - p.x) * videoDisplayInfo.width + videoRect.left + videoDisplayInfo.offsetX;
            const y = p.y * videoDisplayInfo.height + videoRect.top + videoDisplayInfo.offsetY;
            
            return {
                x: x,
                y: y,
                z: p.z
            };
        }

        function toScreenHand(p) {
            // For hands, MediaPipe coordinates are already in 0-1 range
            // Map to actual displayed video area
            const x = (1 - p.x) * videoDisplayInfo.width + videoRect.left + videoDisplayInfo.offsetX;
            const y = p.y * videoDisplayInfo.height + videoRect.top + videoDisplayInfo.offsetY;
            
            return {
                x: x,
                y: y,
                z: p.z || 0
            };
        }

        /* =====================================================
           EARRING LOGIC (ISOLATED)
        ===================================================== */

        function updateEarrings(lm, size) {
            // ============================================
            // EARRING POSITION OFFSETS - ADJUST HERE
            // ============================================
            // Adjust these values to fine-tune earring positions:
            const OFFSET_HORIZONTAL = 0.20;         // Outward from head (0.1-0.35)
            const OFFSET_VERTICAL = 0.16;           // Base down from lobe (lower = higher)
            const OFFSET_VERTICAL_EXTRA = -0.10;    // Additional scaled shift; negative lifts up
            const OFFSET_X_PIXELS_LEFT = 5;         // Extra X for left ear (+ moves right on screen)
            const OFFSET_X_PIXELS_RIGHT = 0;        // Extra X for right ear (+ moves left on screen)
            const OFFSET_Y_PIXELS = 0;              // Additional Y offset in pixels (-20 to +20)
            // ============================================

            // Landmarks:
            // 234 (L tragion), 454 (R tragion)
            // 132 (L earlobe / lower ear), 361 (R earlobe / lower ear)
            const L_lobe = toScreen(lm[132]);
            const R_lobe = toScreen(lm[361]);

            // Fallback direction using tragion/back to keep facing correction
            const L_root = toScreen(lm[234]);
            const L_back = toScreen(lm[93]);
            const R_root = toScreen(lm[454]);
            const R_back = toScreen(lm[323]);

            function anchor(lobe, root, back, isLeft) {
                // Direction from root to back to know ear facing
                const dx = back.x - root.x;
                const dy = back.y - root.y;
                const len = Math.hypot(dx, dy) || 1;
                const nx = dx / len;
                const ny = dy / len;

                // Position at lobe, then offset outward and downward
                return {
                    x: lobe.x
                       + (isLeft ? 1 : -1) * (size * OFFSET_HORIZONTAL)
                       + (isLeft ? OFFSET_X_PIXELS_LEFT : -OFFSET_X_PIXELS_RIGHT)
                       + nx * size * 0.05,
                    y: lobe.y
                       + size * (OFFSET_VERTICAL + OFFSET_VERTICAL_EXTRA)
                       + OFFSET_Y_PIXELS
                       + ny * size * 0.05,
                    z: lobe.z
                };
            }

            const L = anchor(L_lobe, L_root, L_back, true);
            const R = anchor(R_lobe, R_root, R_back, false);

            smooth.earL.x = lerp(smooth.earL.x || L.x, L.x, SMOOTH);
            smooth.earL.y = lerp(smooth.earL.y || L.y, L.y, SMOOTH);
            smooth.earR.x = lerp(smooth.earR.x || R.x, R.x, SMOOTH);
            smooth.earR.y = lerp(smooth.earR.y || R.y, R.y, SMOOTH);

            const Z_THRESHOLD = 0.015;
            const showLeft = (R.z - L.z) > -Z_THRESHOLD;
            const showRight = (L.z - R.z) > -Z_THRESHOLD;

            if (showLeft) render(earL, smooth.earL.x, smooth.earL.y, size);
            else earL.style.display = "none";

            if (showRight) render(earR, smooth.earR.x, smooth.earR.y, size);
            else earR.style.display = "none";
        }

        /* =====================================================
           NECKLACE LOGIC (ISOLATED)
        ===================================================== */

        function updateNecklace(lm, size) {
            if (!showNecklace) return;

            const jawL = toScreen(lm[172]);
            const jawR = toScreen(lm[397]);

            const nose = toScreen(lm[1]);
            const chin = toScreen(lm[152]);


            const faceHeightPx = Math.hypot(
                nose.x - chin.x,
                nose.y - chin.y
            );


            const heightOffset = parseInt(sliderHeight.value, 10);
            console.log("heightOffset -> ", heightOffset / 2);
            const necklaceSize = clamp(
                faceHeightPx * heightOffset / 2, // tune: 0.9 ‚Üí 1.3
                // faceHeightPx * 4.3, // tune: 0.9 ‚Üí 1.3
                90,                 // min size
                280                 // max size
            );

            // Get offset from slider (range -100 to 100 pixels, adjustable)


            const centerX = (jawL.x + jawR.x) / 2;
            const centerY = (jawL.y + jawR.y) / 2 + size * 0.6;

            smooth.neck.x = lerp(smooth.neck.x || centerX, centerX, SMOOTH);
            smooth.neck.y = lerp(smooth.neck.y || centerY, centerY, SMOOTH);

            render(necklaceEl, smooth.neck.x, smooth.neck.y + 2 * (heightOffset / 5), necklaceSize);
        }

        /* =====================================================
           HAND BRACELET LOGIC (ISOLATED)
        ===================================================== */

        function updateBracelet(landmarks) {
            if (!showBracelet) return;

            // MediaPipe Hands landmarks:
            // 0: Wrist
            // 4: Thumb tip
            // 8: Index finger tip
            // 12: Middle finger tip
            // 16: Ring finger tip
            // 20: Pinky tip
            // 9: Index finger MCP (knuckle)
            // 13: Middle finger MCP
            // 17: Ring finger MCP
            // 5: Thumb MCP

            const wrist = toScreenHand(landmarks[0]);
            const indexMCP = toScreenHand(landmarks[9]);
            const middleMCP = toScreenHand(landmarks[13]);
            const ringMCP = toScreenHand(landmarks[17]);

            // Calculate wrist width (distance between index and ring finger MCPs)
            const wristWidth = Math.hypot(
                ringMCP.x - indexMCP.x,
                ringMCP.y - indexMCP.y
            );

            // Calculate angle for bracelet rotation
            // Use hand direction (wrist to middle finger) to get forward direction of hand
            const handDx = middleMCP.x - wrist.x;
            const handDy = middleMCP.y - wrist.y;
            // Calculate hand angle
            const handAngle = Math.atan2(handDy, handDx) * (180 / Math.PI);
            // Add 90 degrees to make bracelet perpendicular (opposite/wrapped around) to hand direction
            const angle = handAngle + 90;

            // Position bracelet at wrist, slightly offset upward
            const braceletX = wrist.x;
            const braceletY = wrist.y - wristWidth * 0.1;

            // Size based on wrist width
            const braceletSize = clamp(wristWidth * 1.2, 60, 200);

            smooth.bracelet.x = lerp(smooth.bracelet.x || braceletX, braceletX, SMOOTH);
            smooth.bracelet.y = lerp(smooth.bracelet.y || braceletY, braceletY, SMOOTH);
            smooth.bracelet.angle = lerp(smooth.bracelet.angle || angle, angle, SMOOTH);

            renderBracelet(braceletEl, smooth.bracelet.x, smooth.bracelet.y, braceletSize, smooth.bracelet.angle);
        }

        /* =====================================================
           FINGER RING LOGIC (ISOLATED)
        ===================================================== */

        function updateFingerRing(landmarks) {
            if (!showFingerRing) return;

            // MediaPipe Hands landmarks (21 landmarks per hand):
            // 0: Wrist
            // 1-4: Thumb (1=CMC, 2=MCP, 3=IP, 4=tip)
            // 5-8: Index finger (5=MCP, 6=PIP, 7=DIP, 8=tip)
            // 9-12: Middle finger (9=MCP, 10=PIP, 11=DIP, 12=tip)
            // 13-16: Ring finger (13=MCP, 14=PIP, 15=DIP, 16=tip) - FOURTH FINGER
            // 17-20: Pinky (17=MCP, 18=PIP, 19=DIP, 20=tip) - FIFTH FINGER

            // Use ring finger (fourth finger) for ring placement
            const ringFingerTip = toScreenHand(landmarks[16]);      // Ring finger tip
            const ringFingerDIP = toScreenHand(landmarks[15]);      // Ring finger DIP (near tip)
            const ringFingerPIP = toScreenHand(landmarks[14]);      // Ring finger PIP (middle joint)
            const ringFingerMCP = toScreenHand(landmarks[13]);      // Ring finger MCP (base joint)

            // Calculate finger direction from MCP to PIP for proper alignment
            const fingerDx = ringFingerPIP.x - ringFingerMCP.x;
            const fingerDy = ringFingerPIP.y - ringFingerMCP.y;
            // Calculate finger angle
            const fingerAngle = Math.atan2(fingerDy, fingerDx) * (180 / Math.PI);
            // Add 90 degrees to make ring perpendicular (wrapped around) to finger
            const angle = fingerAngle + 90;

            // Position ring at the base of the finger, closer to MCP (where rings are typically worn)
            // Use a point between MCP and PIP, but closer to MCP (about 30% from MCP)
            const ringX = ringFingerMCP.x + (ringFingerPIP.x - ringFingerMCP.x) * 0.3;
            const ringY = ringFingerMCP.y + (ringFingerPIP.y - ringFingerMCP.y) * 0.3;

            // Calculate finger width for ring size (distance between PIP and MCP)
            const fingerWidth = Math.hypot(
                ringFingerPIP.x - ringFingerMCP.x,
                ringFingerPIP.y - ringFingerMCP.y
            );

            // Size based on finger width - adjust multiplier for better fit
            const ringSize = clamp(fingerWidth * 0.6, 12, 40);

            smooth.fingerRing.x = lerp(smooth.fingerRing.x || ringX, ringX, SMOOTH);
            smooth.fingerRing.y = lerp(smooth.fingerRing.y || ringY, ringY, SMOOTH);
            smooth.fingerRing.angle = lerp(smooth.fingerRing.angle || angle, angle, SMOOTH);

            renderFingerRing(fingerRingEl, smooth.fingerRing.x, smooth.fingerRing.y, ringSize, smooth.fingerRing.angle);
        }

        /* =====================================================
           FACE CALLBACK
        ===================================================== */

        function onFace(res) {
            if (!res.multiFaceLandmarks?.length) {
                earL.style.display = earR.style.display = necklaceEl.style.display = "none";
                return;
            }

            // Ensure video display info is calculated
            if (video.videoWidth && video.videoHeight && videoDisplayInfo.width === 0) {
                updateVideoRect();
            }

            const lm = res.multiFaceLandmarks[0];
            const noseZ = lm[1].z;
            const size = clamp((-noseZ) * 180 + 16, 18, 46);

            updateEarrings(lm, size);
            updateNecklace(lm, size * 2);
        }

        /* =====================================================
           HANDS CALLBACK
        ===================================================== */

        function onHands(res) {
            if (!res.multiHandLandmarks?.length) {
                braceletEl.style.display = "none";
                fingerRingEl.style.display = "none";
                return;
            }

            // Ensure video display info is calculated
            if (video.videoWidth && video.videoHeight && videoDisplayInfo.width === 0) {
                updateVideoRect();
            }

            // Use the first detected hand
            const handLandmarks = res.multiHandLandmarks[0];
            updateBracelet(handLandmarks);
            updateFingerRing(handLandmarks);
        }

        /* =====================================================
           RENDER
        ===================================================== */

        function render(el, x, y, size) {
            el.style.display = "block";
            el.style.left = `${x}px`;
            el.style.top = `${y}px`;
            el.style.height = `${size}px`;
            el.style.transform = "translate(-50%, 0)";

            //new one 
            el.style.transformOrigin = "50% 0%";
            el.style.transform = "translate(-50%, 0)";
        }

        function renderBracelet(el, x, y, size, angle) {
            el.style.display = "block";
            el.style.left = `${x}px`;
            el.style.top = `${y}px`;
            el.style.width = `${size}px`;
            el.style.height = "auto";
            el.style.transformOrigin = "50% 50%";
            el.style.transform = `translate(-50%, -50%) rotate(${angle}deg)`;
        }

        function renderFingerRing(el, x, y, size, angle) {
            el.style.display = "block";
            el.style.left = `${x}px`;
            el.style.top = `${y}px`;
            el.style.width = `${size}px`;
            el.style.height = "auto";
            el.style.transformOrigin = "50% 50%";
            el.style.transform = `translate(-50%, -50%) rotate(${angle}deg)`;
        }
    </script>

</body>

</html>